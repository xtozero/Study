# 인스턴스화
## 개요
- 인스턴스화는 일반 템플릿 정의에서 데이터형과 함수를 생성하는 과정이다.
- C++에서 템플릿의 인스턴스화는 약간 뒤얽혀 있는데 템플릿에 의해 **생성된 실체의 정의가 소스코드 내에서 단 한 곳으로 한정되지 않기 때문**이다. 템플릿의 의미, 템플릿이 사용된 위치, 템플릿 인자가 정의된 위치 모두가 생성된 실체에 영향을 준다.

## 주문형 인스턴스화
- C++ 컴파일러가 템플릿 특수화를 만나면 컴파일러는 템플릿 파라미터 자리에 제공된 인자들을 가지고 해당 특수화를 생성한다.
> 여기서 특수화( specialization )는 템플릿의 특정 인스턴스를 가리킬 때 사용된다. 여기서는 명시적 특수화( explicit specialization ) 메커니즘을 가르키는 것이 아니다.

- 이렇게 템플릿의 인스턴스가 자동으로 생성되는 것을 *주문형 인스턴스화*라고 하고 때때로 묵시적 혹은 자동 인스턴스화라고 한다.
- 주문형 인스턴스화가 이루어지려면 **템플릿을 사용하는 시점에서 컴파일러가 템플릿에 대한 전체 정의와 그 멤버 중 일부 정의에 접근할 수 있어야 한다.**
```c++
// INS_01.cpp
template <typename T> class C;	// 선언만

C<int>* p = 0;					// ok 정의가 필요하진 않음.

template <typename T>
class C
{
public:
	void f( );					// 멤버 선언
};								// 템플릿 정의

void g( C<int>& c )				// 클래스 템플릿 선언만 사용됨.
{
	c.f( );						// 클래스 템플릿 멤버 함수의 정의가 사용됨.
}
```
- 템플릿 특수화의 정확한 크기를 알아야 하거나 그런 특수화의 멤버에 접근해야 하는 경우라면 전체 정의가 필요하다. 따라서 위 예제의 c.f(); 함수 호출에서 정의가 필요하다.
- 다음 예제에서는 특수화의 정확한 크기가 필요하므로 클래스 템플릿의 인스턴스화가 필요하다.
```c++
// INS_01.cpp
C<void>* cVoid = new C<void>;
```
- 사실 위 예제의 템플릿에서 T를 어떤 인자 X의 데이터형으로 치환하던 C\<X\>는 빈 클래스일 것이므로 템플릿의 크기가 달라지지 않는다. 하지만 C가 접근 가능한 기본 생성자를 가졌는지를 결정하고 private로 new나 delete 연산자를 오버로딩하지 않았는지 확인하기 위해서 인스턴스화가 필요하다.
- 클래스 템플릿의 멤버에 대한 접근 필요성이 소스코드에 항상 드러나는 것은 아니다. C++ 오버로딩 해석에서는 후보 함수들이 가지는 파라미터의 클래스형을 명시적으로 알아야 한다.
```c++
// INS_01.cpp
template <typename T>
class C
{
public:
	C( int );
};

void candidate( const C<double>& );	// #1
void candidate( int ) {}			// #2

int main( )
{
	candidate( 42 );
}
```
- candidate( 42 ) 이라는 호출은 오버로딩 된 함수 중 #2를 호출한다. *하지만 #1에서의 선언도 candidate( 42 )라는 호출을 위해 사용될 수 있는 후보인지 알아보기 위해 인스턴스화*된다.
- 다만 **인스턴스화 없이 호출을 처리할 수 있다면 인스턴스화되지 않는다.** 따라서 위의 예제에서는 #2가 호출된다. 위 예제에서 #2를 지우면 정의가 없어 에러가 발생한다.

## 게으른 인스턴스화
- 컴파일러는 템플릿을 인스턴스화 할 때 필요한 만큼 인스턴스화해야 하므로 게을러야만 한다.
- 클래스 템플릿이 묵시적으로 인스턴스화될 때 *멤버의 각 선언은 인스턴스화되지만 정의는 인스턴스화되지 않는다.*
- 클래스 템플릿이 *익명 공용체를 가지고 있다면 그 공용체의 정의에 속하는 멤버들도 인스턴스화*된다.
- *가상 멤버 함수의 정의는 템플릿 인스턴스화의 결과에 따라 인스턴스화될 수도 있고 안 될 수도 있다.* 가상 호출 메커니즘을 위한 내부 구조를 만들기 위해서 가상 함수가 링크될 수 있는 실체가 돼야 하기 때문이다.
- 기본 함수 호출 인자는 따로 고려된다. 특히 *기본 인자는 자신들이 실제로 함수에서 사용되지 않는 한 인스턴스화되지 않는다.* 즉 명시적인 인자가 기본 인자 대신 제공되면 기본 인자는 인스턴스화되지 않는다.
```c++
// INS_02.cpp
template <typename T>
class Safe {};

template <int N>
class Danger
{
public:
	typedef char Block[N];		// N <= 0 이면 실패
};

template <typename T, int N>
class Tricky
{
public:
	virtual ~Tricky( ) {}

	void no_body_here( Safe<T> = 3 );
	void inclass( )
	{
		Danger<N> no_boom_yet;
	}
	// void error() { Danger<0> boom; }
	// void unsafe( T( *p )[N] );
	T operator->( );
	// virtual Safe<T> suspect( );
	struct Nested
	{
		Danger<N> pfew;
	};
	union						// 익명 공용체
	{
		int align;
		Safe<T> anonymous;
	};
};

int main( )
{
	Tricky<int, 0> ok;
}
```
- 표준 C++ 컴파일러는 문법과 일반적인 의미상의 제약 조건을 검사하기 위해서 템플릿 정의를 컴파일하는데 *최상의 조건을 가정해 템플릿 파라미터가 포함된 제약 조건을 검사한다.*
- 위 예제의 *Block을 위한 멤버 typedef 내에서 파라미터 N은 0이나 음수일 수 있다. 하지만 컴파일러는 유효한 파라미터가 들어올 것이라고 가정*한다.
- 유사하게 *no_body_here() 에 대한 기본 인자 특수화 선언은 Safe라는 템플릿이 정수로 초기화되지 않지만 Safe\<T\>의 일반적인 정의에서 기본 인자는 필요하지 않다고 가정*한다.
- ~멤버 함수 error는 주석 처리하지 않았다면 Danger\<0\>을 사용할 것이고 컴파일 오류가 발생했을 것이다. 멤버 error가 사용되지도 않고 인스턴스화되지도 않는다 해도 이런 사항은 문제가 된다.~
> 하지만 gcc, VS 2015 community에서 문제가 되지 않았다.

- 이제 main 함수를 살펴보면 Tricky를 T에는 int, N에는 0을 사용하였다. *모든 멤버 정의가 필요하진 않아도 기본 생성자와 소멸자는 분명히 호출되기 때문에 어딘가에 정의가 있어야 한다.*
- *가상 멤버의 정의도 제공돼야 한다.* 아무런 정의도 하지 않은 suspect의 주석을 해제하면 링크 에러가 발생한다.
- 멤버 inclass()와 struct Nested()의 정의는 모두 Danger\<0\>이 필요하지만 이들의 정의는 사용되지도 않고, 생성되지 않기 때문에 오류가 발생하지 않는다. 
- 하지만 모든 멤버 선언은 생성됐고 선언의 파라미터 치환 중 유효하지 않은 데이터형을 가질 수 있다. unsafe( T( *p )[N] );의 선언에 대한 주석을 제거하면 0개의 요소를 가지는 배열을 생성할 것이고 오류가 발생할 것이다.
> 하지만 gcc에서는 정상적으로 컴파일 됐다.

- 마찬가지로 익명 공용체의 멤버 Safe\<T\>를 Danger\<T\>로 선언하면 오류가 발생한다.
- 마지막으로 operator-\>는 일반적으로 포인터형을 반환해야 하나 여기서는 int 형을 반환하므로 에러가 발생해야 한다. 하지만 특정 일반 템플릿 정의에서 이런 종류의 정의를 사용하곤 하므로 사용자 정의 operator-\> 연산자가 오버로딩돼 사용될 때는 다른 operator-\>연산자를 적용할 수 있는 데이터형( 예를 들어 내장형 )만을 반환해야 한다. 따라서 위의 예제에서 템플릿 선언으로 인해 반환형이 int가 되어도 오류가 발생하지 않는다.

## C++ 인스턴스화 모델
- 템플릿 인스턴스화는 템플릿 파라미터를 적절한 인자로 치환하여 일반 클래스나 함수를 만드는 과정이다.
- 굉장히 직관적으로 보이나 실제로 구현하기 위해서는 많은 세부사항이 필요하다.

## 두 단계 룩업
- '10_Name in Templates' 에서 종속 이름에서 템플릿이 정상적으로 파싱되지 않는다. 대신 이들은 인스턴스화 시점에서 다시 룩업된다.
- 하지만 종속되지 않은 이름은 템플릿이 처음 보였을 때 최대한 많은 오류를 진단하기 위해 이른 단계에 룩업을 수행한다.
- 이것이 두 단계 룩업이다. *템플릿을 파싱하는 것이 첫 번째 단계이고 인스턴스화할 때가 두 번째 단계*이다.
- **첫번째 단계에서 종속되지 않은 이름은 템플릿이 파싱되는 동안 일반 룩업 법칙과 적용가능하다면 ADL( 인자 종속 룩업 )에 따라 룩업을 수행**한다.
- 한정되지 않은 종속 이름도 같은 방식으로 룩업되지만 룩업의 결과는 템플릿이 인스턴스화될 때 수행되는 추가적인 룩업이 완료되기 전까지 고려되지 않는다.
- **두 번째 단계는 인스턴스화 지점( POI : Point of instantiation )이라고 불리는 지점에서 템플릿이 인스턴스화 될 때 발생하며 한정된 종속 이름이 룩업되고 한정되지 않은 종속 이름을 위해 추가로 ADL이 수행**된다.

## 인스턴스화 지점
- 인스턴스화 지점은 치환된 템플릿이 삽입될 소스코드 위치를 말한다.
```c++
// INS_03.cpp
class MyInt
{
public:
	MyInt( int i );
};

MyInt operator- ( const MyInt& );

bool operator > ( const MyInt&, const MyInt& );
typedef MyInt Int;

template <typename T>
void f( T i )
{
	if ( i > 0 )
	{
		g( -i );
	}
}

// 1
void g( Int )
{
	// 2
	f<Int>( 42 );
	// 3
}
// 4
```
- C++ 컴파일러가 f\<Int\>(42)라는 호출을 본다면 템플릿 f에서 T를 MyInt로 치환해 인스턴스화해야 한다는 걸 안다.
- 따라서 POI가 생성되는데 위의 예제에서 **2, 3은 호출 지점과 가깝지만 함수 내부에 함수의 정의를 삽입할 수 없으므로 POI가 될 수 없다.**
- 만약 1이 POI였다면 g(Int)가 아직 가시화되지 않았기 때문에 해당 호출은 해석될 수 없다.
- 4에서는 함수 g( Int )가 가시화돼 템플릿 종속 호출인 g( -i )가 해석될 수 있으므로 POI는 4이다.
- C++는 **클래스가 아닌 특수화에 대해 참조하기 위한 POI**는 **해당 참조를 포함하는 가장 가까운 네임스페이스 영역 선언 뒤라고 정의했다.**
- 마지막으로 위의 예제에서 왜 MyInt라는 데이터형을 사용했는지 살펴보면 **POI에서 수행되는 두 번쨰 룩업이 ADL**이기 때문이다. int는 연관된 네임스페이스를 갖지 않기 때문에 POI에서 룩업이 일어날 수 없으므로 결국 함수 g를 찾지 못할 것이다.
> gcc 에서는 컴파일 에러 vs 2015 community에서는 컴파일은 된다.

- 클래스 특수화에서는 상황이 좀 달라진다.
```c++
// INS_04.cpp
template <typename T>
class S
{
public:
	T m;
};

// 1
unsigned long h( )
{
	// 2
	return ( unsigned long )sizeof( S<int> );
	// 3
}
// 4
```
- 함수 내부에 클래스의 정의가 삽입될 수는 없으므로 2와 3은 마찬가지로 POI가 아니다.
- 클래스가 인스턴스에 대한 법칙을 따르면 4가 되겠지만 그러면 sizeof로 실제 크기를 결정할 수 없으므로 유효하지 않다.
- 그래서 해당 인스턴스에 대한 참조를 포함한 **인접 네임스페이스 영역 선언이나 정의가 끝나자마자 생성된 클래스 인스턴스에 대한 참조를 위해 POI가 생긴다.** 따라서 1이 POI이다.
- 템플릿이 실제로 인스턴스화될 때 추가적인 인스턴스화가 나타날 수 있다.
```c++
// INS_05.cpp
template <typename T>
class S
{
public:
	typedef int I;
};

// 1
template <typename T>
void f( )
{
	S<char>::I var1 = 41;
	typename S<T>::I var2 = 42;
}

int main( )
{
	f<double>( );
}
// 2
// 2a
// 2b
```
- f\<double\> 를 위한 POI는 2에 만들어진다. 함수 템플릿 f()는 1에 만들어진 POI의 클래스 특수화 S\<char\>를 참조한다. 또한, S\<T\>도 참조하지만 아직 종속적이기 때문에 여기서 실제로 인스턴스화할 수 없다. 하지만 2에서 f\<double\>를 인스턴스화했다면 S\<double\>의 정의도 인스턴스화 할 필요가 있다.
- 이런 이차적이거나 과도기적인 POI들은 약간 다른 방식으로 정의되는데 클래스가 아닌 실체의 경우 2차 POI는 원 POI와 정확히 같다. 클래스 실체의 경우 2차 POI는 원 POI의 직전에 나온다.
- 즉 위 예제에서는 f\<double\>가 2b에 S\<double\>가 2a에 2차 POI를 가진다.
- 일반적으로 한 번역 단위 내에서도 같은 인스턴스에 대해 여러 POI를 가질 수 있다. 이 경우 클래스와 클래스가 아닌 경우 POI를 유지하는 방식이 다르다.

1\. 클래스 인스턴스 : 각 번역 단위에서 첫 번째 POI만을 유지하고 나머지 POI들은 무시한다. ( 이들은 POI로 취급하지 않는다. )

2\. 클래스가 아닌 인스턴스 : 모든 POI를 유지한다.

- **두 경우 모두 모든 POI들이 ODR의 요구에 따라 모두 같은 인스턴스가 만들어져야 한다.**( C++ 컴파일러가 ODR 법칙을 위반하는지를 검증하거나 진단할 필요는 없다. ) 따라서 C++ 컴파일러는 다른 POI가 다른 인스턴스를 생성하는 것을 걱정할 필요 없이 클래스가 아닌 POI를 실제로 인스턴스화 할 때 하나의 POI를 선택할 수 있다.
- 실제로 많은 컴파일러가 번역 단위 끝에 이를 때까지 인라인이 아닌 함수 템플릿의 실제 인스턴스화를 미룬다. 이른 통해 해당 템플릿 특수화의 POI를 번역단위 끝으로 옮길 수 있다. 하지만 C++ 표준에 정확히 언급돼 있진 않다.

## 포함과 분리 모델
- POI를 만날 때마다 POI에서 요구하는 템플릿의 정의는 어떤 방식으로든 접근 가능해야 한다. **클래스 특수화에서 접근 가능하다는 것은 클래스 템플릿 정의가 번역 단위 내의 앞부분에 나타나야 한다**는 뜻이다.
- 클래스가 아닌 POI에서도 상황은 비슷하며 일반적으로 클래스가 아닌 템플릿 정의는 #include를 통해 헤더 파일을 추가하여 번역 단위에 포함하는데 이런 방식을 포함 모델이라고 하며 가장 널리 사용되는 접근 방식이다.
- 분리 모델은 구현한 컴파일러가 없고 C++11 export 키워드가 표준에서 사용하지 않는 예약어로 변경되었기 때문에( [참고](http://en.cppreference.com/w/cpp/keyword/export) ) 생략한다.

## 명시적 인스턴스화
- *템플릿 특수화를 위한 인스턴스화 지점을 명시적으로 생성*할 수도 있다. 이런 방식을 **명시적 인스턴스화**라고 한다.
```c++
// INS_06.cpp
template <typename T>
void f( T ) throw ( T )
{
}

template void f<int>( int ) throw( int );
template void f<>( float ) throw( float );
template void f( long ) throw( int );
template void f( char );
```
- 위 예제의 모든 인스턴스화 지시자는 유효하다. 템플릿 인자는 추론될 수 있으며, 예외 특수화는 생략될 수 있다.
> 예외 특수화의 경우 생략하면 vs 2015 community에서는 컴파일 실패한다. gcc는 문제없이 컴파일된다.

- 클래스 템플릿의 멤버 역시 다음과 같이 명시적으로 인스턴스화될 수 있다.
```c++
// INS_06.cpp
template <typename T>
class S
{
public:
	void f( )
	{

	}
};

template void S<int>::f( );

template class S<void>;
```
- 클래스 템플릿 특수화의 모든 멤버는 명시적으로 인스턴스화되는 클래스 템플릿 특수화를 통해 명시적으로 인스턴스화될 수 있다.
- 만약 템플릿 특수화가 명시적으로 인스턴스화 된다면 명시적으로 특수화돼서는 안 되며 반대로 명시적으로 특수화된 다음 명시적으로 인스턴스화하면 명시적 인스턴스화는 아무런 영향을 미치지 못한다.
```c++
template <typename T>
void toast( const T& x )
{
	std::cout << "function template" << std::endl;
}

template void toast( const float& x );

// 명시적 인스턴스화 다음 명시적으로 특수화할 수 없다.
template <>
void toast( const float& x )
{
	std::cout << "explicit specialization" << std::endl;
}

// 명시적 인스턴스화 구문이 특수화 다음에 나타나면 아무런 효과가 없다.

int main( )
{
	float a;
	toast( a );
}
```
- 암시적인 템플릿 인스턴스화가 빌드 시간에 부정적인 영향을 미치기 때문에 빌드 시간 개선을 위해 특정 템플릿 특수화를 한 곳에서 수동으로 인스턴스화시키고, 다른 번역 단위에서는 관련 인스턴스화를 억제하는 방식을 활용할 수 있다.
```c++
// INS_07_TR1.h
template <typename T> void f( );

void g( );

// INS_07_TR1.cpp
void g( )
{
	f<int>( );
}

// INS_07.cpp
template <typename T> void f( )
{
	std::cout << "f<int>() called" << std::endl;
}

template void f<int>( );

int main( )
{
	g( );
}
```
- 위 예제는 잘 동작하지만 템플릿 인터페이스를 제공하는 소스코드에 대한 제어가 필요한데 그러지 못하는 경우가 많다. 템플릿을 제공하는 소스 코드는 수정하지 못할 수 있으며 대체로 템플릿의 정의만이 제공된다.
- 이를 해결하기 위한 한가지 트릭은 템플릿을 특수화가 명시적으로 인스턴스화된 번역 단위를 제외한 나머지 모든 번역 단위(= 인스턴스화를 억제하려고 하는 번역 단위 )에서 해당 템플릿을 특수화로 선언하는 방법이 있다.
```c++
// INS_08_TR1.cpp
template <typename T> void f( )
{
	std::cout << "f() TR1" << std::endl;
}

template <> void f<int>( );	// 특수화로 선언

void g( )
{
	f<int>( );
}

// INS_08.cpp
template <typename T> void f( )
{
	std::cout << "f()" << std::endl;
}

template void f<int>( );

void g( );

int main( )
{
	g( );
}
```
- 일부 컴파일러는 템플릿 특수화가 해당 번역 단위에서 인스턴스화되지 않아도 된다는 확장 기능을 제공한다. 명시적 인스턴스화 지시자 전에 extern을 덧붙이면 암시적 인스턴스화 단계를 건너뛴다. ( [C++ 11부터 표준](http://en.cppreference.com/w/cpp/language/class_template) )
```c++
// INS_08_TR1.cpp
extern template void f<int>( );	// 선언됐으나 정의되지 않음
```